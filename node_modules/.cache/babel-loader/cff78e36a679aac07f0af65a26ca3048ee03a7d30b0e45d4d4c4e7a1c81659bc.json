{"ast":null,"code":"import pdfParse from 'pdf-parse';\nimport mammoth from 'mammoth';\nexport const extractTextFromPDF = async file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = async () => {\n      try {\n        const arrayBuffer = reader.result;\n        const uint8Array = new Uint8Array(arrayBuffer);\n        const data = await pdfParse(uint8Array);\n        resolve(data.text);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => reject(reader.error);\n    reader.readAsArrayBuffer(file);\n  });\n};\nexport const extractTextFromDOCX = async file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = async () => {\n      try {\n        const arrayBuffer = reader.result;\n        mammoth.extractRawText({\n          arrayBuffer\n        }).then(result => resolve(result.value)).catch(reject);\n      } catch (error) {\n        reject(error);\n      }\n    };\n    reader.onerror = () => reject(reader.error);\n    reader.readAsArrayBuffer(file);\n  });\n};\nexport const parseResume = async file => {\n  let rawText;\n  try {\n    if (file.type === 'application/pdf') {\n      rawText = await extractTextFromPDF(file);\n    } else if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || file.name.toLowerCase().endsWith('.docx')) {\n      rawText = await extractTextFromDOCX(file);\n    } else {\n      throw new Error('Unsupported file type. Please upload a PDF or DOCX file.');\n    }\n    const extractedData = extractFieldsFromText(rawText);\n    return {\n      ...extractedData,\n      rawText\n    };\n  } catch (error) {\n    throw new Error(`Failed to parse resume: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n};\nconst extractFieldsFromText = text => {\n  const data = {};\n\n  // Extract name (usually at the beginning, capitalize first)\n  const nameMatch = text.match(/^([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)/m);\n  if (nameMatch) {\n    data.name = nameMatch[1].trim();\n  }\n\n  // Extract email\n  const emailMatch = text.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})/);\n  if (emailMatch) {\n    data.email = emailMatch[1].toLowerCase();\n  }\n\n  // Extract phone (various formats)\n  const phonePatterns = [/(\\+?1?[-.\\s]?)?\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})/, /(\\+91[-.\\s]?)?([0-9]{5})[-.\\s]?([0-9]{5})/, /(\\+?[0-9]{1,3}[-.\\s]?)?[0-9]{3,4}[-.\\s]?[0-9]{3,4}[-.\\s]?[0-9]{3,4}/];\n  for (const pattern of phonePatterns) {\n    const phoneMatch = text.match(pattern);\n    if (phoneMatch) {\n      data.phone = phoneMatch[0].replace(/[-.\\s]/g, '').trim();\n      break;\n    }\n  }\n  return data;\n};","map":{"version":3,"names":["pdfParse","mammoth","extractTextFromPDF","file","Promise","resolve","reject","reader","FileReader","onload","arrayBuffer","result","uint8Array","Uint8Array","data","text","error","onerror","readAsArrayBuffer","extractTextFromDOCX","extractRawText","then","value","catch","parseResume","rawText","type","name","toLowerCase","endsWith","Error","extractedData","extractFieldsFromText","message","nameMatch","match","trim","emailMatch","email","phonePatterns","pattern","phoneMatch","phone","replace"],"sources":["C:/swipe_Assessmentme/src/utils/resumeParser.ts"],"sourcesContent":["import pdfParse from 'pdf-parse';\r\nimport mammoth from 'mammoth';\r\nimport { ResumeData } from '../types';\r\n\r\nexport const extractTextFromPDF = async (file: File): Promise<string> => {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    reader.onload = async () => {\r\n      try {\r\n        const arrayBuffer = reader.result as ArrayBuffer;\r\n        const uint8Array = new Uint8Array(arrayBuffer);\r\n        const data = await pdfParse(uint8Array);\r\n        resolve(data.text);\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    };\r\n    reader.onerror = () => reject(reader.error);\r\n    reader.readAsArrayBuffer(file);\r\n  });\r\n};\r\n\r\nexport const extractTextFromDOCX = async (file: File): Promise<string> => {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    reader.onload = async () => {\r\n      try {\r\n        const arrayBuffer = reader.result as ArrayBuffer;\r\n        mammoth.extractRawText({ arrayBuffer })\r\n          .then((result) => resolve(result.value))\r\n          .catch(reject);\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    };\r\n    reader.onerror = () => reject(reader.error);\r\n    reader.readAsArrayBuffer(file);\r\n  });\r\n};\r\n\r\nexport const parseResume = async (file: File): Promise<ResumeData> => {\r\n  let rawText: string;\r\n  \r\n  try {\r\n    if (file.type === 'application/pdf') {\r\n      rawText = await extractTextFromPDF(file);\r\n    } else if (\r\n      file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ||\r\n      file.name.toLowerCase().endsWith('.docx')\r\n    ) {\r\n      rawText = await extractTextFromDOCX(file);\r\n    } else {\r\n      throw new Error('Unsupported file type. Please upload a PDF or DOCX file.');\r\n    }\r\n\r\n    const extractedData = extractFieldsFromText(rawText);\r\n    return {\r\n      ...extractedData,\r\n      rawText\r\n    };\r\n  } catch (error) {\r\n    throw new Error(`Failed to parse resume: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n  }\r\n};\r\n\r\nconst extractFieldsFromText = (text: string): Partial<ResumeData> => {\r\n  const data: Partial<ResumeData> = {};\r\n  \r\n  // Extract name (usually at the beginning, capitalize first)\r\n  const nameMatch = text.match(/^([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)/m);\r\n  if (nameMatch) {\r\n    data.name = nameMatch[1].trim();\r\n  }\r\n  \r\n  // Extract email\r\n  const emailMatch = text.match(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})/);\r\n  if (emailMatch) {\r\n    data.email = emailMatch[1].toLowerCase();\r\n  }\r\n  \r\n  // Extract phone (various formats)\r\n  const phonePatterns = [\r\n    /(\\+?1?[-.\\s]?)?\\(?([0-9]{3})\\)?[-.\\s]?([0-9]{3})[-.\\s]?([0-9]{4})/,\r\n    /(\\+91[-.\\s]?)?([0-9]{5})[-.\\s]?([0-9]{5})/,\r\n    /(\\+?[0-9]{1,3}[-.\\s]?)?[0-9]{3,4}[-.\\s]?[0-9]{3,4}[-.\\s]?[0-9]{3,4}/\r\n  ];\r\n  \r\n  for (const pattern of phonePatterns) {\r\n    const phoneMatch = text.match(pattern);\r\n    if (phoneMatch) {\r\n      data.phone = phoneMatch[0].replace(/[-.\\s]/g, '').trim();\r\n      break;\r\n    }\r\n  }\r\n  \r\n  return data;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}